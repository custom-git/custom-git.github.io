#!/usr/bin/env bash

function __happy_exit_message() {
    printf "\rcustom-git commands are enabled for this shell session.\n"
    printf "Have fun ...\n\n"
}

if [[ -n "$_CUSTOM_GIT_TRY_" ]]; then
    echo
    __happy_exit_message
    return
fi

__SUCCESS=0
__FAILURE=1

__exec_status=$__SUCCESS

function __is_fzf_installed() {

    if command -v fzf &>/dev/null; then
        echo true
    else
        echo false
    fi
}

function __handle_fzf_installation() {

    printf "\ncustom-git requires fzf (fuzzy finder) to work.\nAllow me to install it on your system? (y/n) : "
    read __continue
    if [[ "$__continue" != "y" ]]; then
        __fzf_installation_status=$__FAILURE
        return
    fi
    echo

    __curDir=$(pwd)

    printf "Installing fzf ..."
    git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf &> /dev/null
    cd ~/.fzf/
    ./install --all &> /dev/null

    cd $__curDir
}

if [[ $(__is_fzf_installed) == false ]]; then
    
    __fzf_installation_status=$__SUCCESS
    __handle_fzf_installation
    if [[ $__fzf_installation_status -eq $__FAILURE ]]; then
        printf "\nPlease install fzf from \"https://github.com/junegunn/fzf#installation\"\nand try again...\n\n"
        return
    fi
    printf "\rfzf installed successfully.\n\n"
    echo "Restart your shell and run the custom-git 'try' command again."
    printf "\n\
    if command -v curl >/dev/null 2>&1; then\n\
        source <(curl -fsSL https://custom-git.io/try)\n\
    else\n\
        source <(wget -qO- https://custom-git.io/try)\n\
    fi\n"
    return
fi

printf "\nEnabling custom-git commands ..."

FZF_WIDGET_TMUX=1
export FZF_DEFAULT_OPTS="--height 80% --reverse --border --ansi --preview-window 'right:60%:wrap' --layout reverse --margin=1,4"

function gadd() {

    __assertgitrepo
    if [[ $__exec_status -eq $__FAILURE ]]; then
        return
    fi

    # check for command line arguments
    if [[ $# -gt 0 ]]; then
        # use command line arguments
        git add $*
    else
        __stage_modified_files
        __stage_untracked_files
    fi

    gstatus
}

function __stage_modified_files() {

    numModified=$(git diff --name-only | wc -l)
    if [[ $numModified -eq 0 ]]; then
        return
    fi
    gstatus
    printf "\nstage modified files? (press enter / n) : "
    read __continue
    if [[ $__continue == "n" ]]; then
        return
    fi

    git diff --name-only | sed 's/\* //g' | fzf -m --color fg:160 | \
        while read -r __file; do
            __file=$(echo "$__file" | xargs -I '{}' echo '{}')
            git add "$__file"
        done
}


function __stage_untracked_files() {

    numUntracked=$(git status --porcelain | grep "^?? " | wc -l)
    if [[ $numUntracked -eq 0 ]]; then
        return
    fi
    gstatus
    printf "\nstage untracked files? (press enter / n) : "
    read __continue
    if [[ $__continue == "n" ]]; then
        return
    fi

    git status --porcelain | grep "^?? " | sed -e 's/^[?]* //' | fzf -m --color fg:160 | \
        while read -r __file; do
            __file=$(echo "$__file" | xargs -I '{}' echo '{}')
            git add "$__file"
        done
}

function gstatus() {
    
    __assertgitrepo
    if [[ $__exec_status -eq $__FAILURE ]]; then
        return
    fi

    clear
    git status
}

# util
function __isgitrepo() {

    if git rev-parse --git-dir > /dev/null 2>&1; then
        # This is a valid git repository.
        echo true
    else
        echo false
    fi
}

function __assertgitrepo() {

    if [[ $(__isgitrepo) == false ]]; then
        echo "[AssertionError] not a git repo."
        __exec_status=$__FAILURE
    fi
}

__happy_exit_message
_CUSTOM_GIT_TRY_="enabled"
